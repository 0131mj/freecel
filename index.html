<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Free Cell</title>
    <style>
        body {
            background-color: green;
        }

        #stage {
            display: flex;
            flex-wrap: wrap;
        }

        .cell {
            width: 86px;
            height: 128px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 4px;
        }

        header {
            display: flex;
            justify-content: center;
        }

        #free-cells {
            display: flex;
        }

        #home-cells {
            display: flex;
        }

        #cascades {
            display: flex;
            justify-content: center;
        }

        .cascade {
            display: flex;
            flex-direction: column-reverse;
            justify-content: flex-end;
        }

        .card {
            margin: 4px;
            border-radius: 4px;
            /*padding: 30px;*/
            font-size: 26px;
            font-weight: bold;
            background-color: #aaa;
            display: flex;
            /*flex-direction: column;*/
            justify-content: center;
        }

        .draggable {
            background-color: #fff;
            cursor: move;
        }

        .droppable {
            background-color: yellow;
            height: 100%;
            padding-bottom: 60px;
        }

        .drag-handler {
            padding-bottom: 20px;
        }

    </style>

</head>
<body>
<header>
    <div id="free-cells">
        <div class="cell" data-free="0"></div>
        <div class="cell" data-free="1"></div>
        <div class="cell" data-free="2"></div>
        <div class="cell" data-free="3"></div>
    </div>
    <div style="width: 50px">
    </div>
    <div id="home-cells">
        <div class="cell" data-home="0"></div>
        <div class="cell" data-home="1"></div>
        <div class="cell" data-home="2"></div>
        <div class="cell" data-home="3"></div>
    </div>
</header>
<div id="cascades">
    <div class="cascade cell" data-cascade="0"></div>
    <div class="cascade cell" data-cascade="1"></div>
    <div class="cascade cell" data-cascade="2"></div>
    <div class="cascade cell" data-cascade="3"></div>
    <div class="cascade cell" data-cascade="4"></div>
    <div class="cascade cell" data-cascade="5"></div>
    <div class="cascade cell" data-cascade="6"></div>
    <div class="cascade cell" data-cascade="7"></div>
</div>
<div id="stage"></div>
</body>
<script>

    /**
     * 구성요소
     *    카드 : 총 52장 (4가지 모양 * 13개 카드)
     *    무대
     *      홈셀
     *      프리셀
     *      캐스케이드
     * 게임 방법
     *    캐스케이드와 프리셀의 카드를 모두 홈셀로 이동
     * 룰
     *    홈셀 :
     *       - 총 적재 가능 수량 : 제한 없음 (논리적으로는 모양이 같은 카드의 총 개수)
     *       - 적재 가능 카드 : 현재 카드와 모양이 같고, 현재카드의 번호보다 1이 큰 값의 카드
     *    프리셀 :
     *       - 총 적재 가능 수량 : 1장
     *       - 적재 가능 카드 : 모든 카드
     *    캐스케이드 :
     *       - 총 적재 가능 수량 : 제한 없음 (논리적으로는 모든 카드의 개수)
     *       - 적재 가능 카드 : 현재 카드와 색상이 다르고 현재카드의 번호보다 1이 큰 값의 카드
     *       - 한번에 드래그 가능 수량 : 프리셀의 빈 데크 수량,
     *       - 한번에 드롭 가능 수량 : 제한 없음



     * 게임 시작
     *   초기상태
     *    홈셀 : 없음 ok
     *    프리셀 : 없음 ok
     *    캐스케이드: 카드 수량을 나누어 랜덤으로 배열함 ok
     *      추가(캐스케이드에 추가로 지정)
     * 게임 끝
     *  캐스케이드와 프리셀의 카드를 모두 홈셀로 이동하면 끝 ok
     * */

    class Game {
        constructor(props) {
            this.homeCells = this.makeBlankFields(4);
            this.freeCells = this.makeBlankFields(4);
            this.cascades = this.makeBlankFields(8);
            this.cardTypes = ["♥", "◆", "♣", "♠"];
            this.cardTexts = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
            this.cards = this.cardTexts.reduce((cards, text) => {
                this.cardTypes.forEach(type => {
                    cards.push({
                        type,
                        text,
                        detachable: false,
                    })
                })
                return cards;
            }, []);
            this.movingCards = [];
        }

        makeBlankFields = (length) => [...Array(length)].map(n => ({
            attachable:false,
            fields: [],
        }));

        start() {
            this.homeCells = this.makeBlankFields(4);
            this.freeCells = this.makeBlankFields(4);
            this.cascades = this.makeBlankFields(8);
            this.cards.reverse().forEach((card) => {
                const colNum = Math.floor((Math.random() * this.cascades.length));
                this.cascades[colNum].fields.push(card);
                // console.log(card, colNum)
            });
            this.movingCards = [];
            this.getDetachableCards();
            console.log(this);
        }

        getColorFromShape(type) {
            return ["♣", "♠"].includes(type) ? "black" : "red";
        }

        /**
         * 떼어낼 수 있는 카드들을 찾아 속성 변경 처리
         */
        getDetachableCards() {
            // - 홈셀: 모든 카드 하나씩
            this.homeCells.forEach(({fields}) => {
                fields.forEach(card => {
                    card.detachable = true;
                })
            });
            // - 프리셀: 모든 카드 하나씩
            this.freeCells.forEach(({fields}) => {
                if (fields[fields.length - 1]) {
                    fields[fields.length - 1].detachable = true;
                }
            });
            // - 캐스케이드: 맨 아래에서부터 ~ 색이 다르고 숫자가 1씩 감소하는 카드까지만 (1~n)
            this.cascades.forEach(({fields}) => {
                let prevCard = null;
                let idx = fields.length - 1;
                while (idx >= 0) {
                    const card = fields[idx];
                    if (!prevCard) {
                        card.detachable = true;
                    } else {
                        const prevIndex = this.cardTexts.indexOf(prevCard.text);
                        const cardIndex = this.cardTexts.indexOf(card.text);
                        const isLinear = prevIndex + 1 === cardIndex;

                        const prevColor = this.getColorFromShape(prevCard.type);
                        const cardColor = this.getColorFromShape(card.type);
                        const isDiffColor = prevColor !== cardColor;

                        const detachable = isLinear && isDiffColor;
                        card.detachable = detachable;
                        if (!detachable) {
                            break;
                        }
                    }
                    prevCard = card;
                    idx--;
                }
            })
        }

        preDetach(cards) {
            this.movingCards = cards;
        }

        rollBack() {
            this.movingCards = [];
        }

        getAttachableZone() {
            this.homeCells.attachable = true;
            this.homeCells.attachable = true;
            // - 홈셀 : 카드 1개만, 비어있을 경우 A만,
            // - 프리셀 : 카드 1개만 (어떤 카드든)
            // - 캐스케이드: moving 카드가 쌓여있던 카드의 마지막 카드에서 색이 다르고 숫자가 1 감소하는 카드로 끝나는 더미만
        }

        checkMovable() {
            // 1. take from
            // 2. moving....
            // 3. put onto
            /** moving Card 즉 떼어낸 카드를 붙일 수 있는지
             * 어디서 떼어내서 어디로 가져갈지 모르므로, '이동' 이라는 단순한 액션으로 규정하기보단
             * 1) 떼어내기,  2) 떼어낸 카드를 붙여넣기 로 구분
             *
             * 1. get detachable card
             * 2. pre-detach
             * 3. checkAttachable => detach & attach
             * **/
            // detachable card :
            // 결정시점 - 매번 카드가 옮겨진 후
            this.getDetachableCards();

            // attachable area:
            // 결정시점 - detachable card 변경 후
            this.getAttachableZone();

        }

        move() {
            this.checkIsFailed();
            this.checkIsFinished();
        }

        checkIsFailed() {
            /**
             * 이동 할 수 있는 카드가 없다고 판단하기
             * **/
            const isFailed = false;
            if (isFailed) {
                this.fail();
            } else {
                console.log("안 실패")
            }
        }

        checkIsFinished() {
            const homeCellTotalCardCnt = this.homeCells.reduce((totalCnt, homeCell) => totalCnt + homeCell.length, 0)
            const isFinished = this.cards.length === homeCellTotalCardCnt;
            if (isFinished) {
                this.finish();
            } else {
                console.log("안 끝남")
            }
        }

        fail() {

        }

        finish() {
            console.log(" 끝")
        }


    }

    new Game().start();
</script>
<script src="script.js"></script>
</html>